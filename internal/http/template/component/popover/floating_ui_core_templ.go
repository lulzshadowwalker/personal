// Code generated by templ - DO NOT EDIT.

// templ: version: v0.3.865
// templui component popover - version: main installed by templui v0.71.0

package popover

//lint:file-ignore SA4006 This context is only used if a nested component is present.

import "github.com/a-h/templ"
import templruntime "github.com/a-h/templ/runtime"

// https://cdn.jsdelivr.net/npm/@floating-ui/core@1.7.0
func FloatingUICore() templ.Component {
	return templruntime.GeneratedTemplate(func(templ_7745c5c3_Input templruntime.GeneratedComponentInput) (templ_7745c5c3_Err error) {
		templ_7745c5c3_W, ctx := templ_7745c5c3_Input.Writer, templ_7745c5c3_Input.Context
		if templ_7745c5c3_CtxErr := ctx.Err(); templ_7745c5c3_CtxErr != nil {
			return templ_7745c5c3_CtxErr
		}
		templ_7745c5c3_Buffer, templ_7745c5c3_IsBuffer := templruntime.GetBuffer(templ_7745c5c3_W)
		if !templ_7745c5c3_IsBuffer {
			defer func() {
				templ_7745c5c3_BufErr := templruntime.ReleaseBuffer(templ_7745c5c3_Buffer)
				if templ_7745c5c3_Err == nil {
					templ_7745c5c3_Err = templ_7745c5c3_BufErr
				}
			}()
		}
		ctx = templ.InitializeContext(ctx)
		templ_7745c5c3_Var1 := templ.GetChildren(ctx)
		if templ_7745c5c3_Var1 == nil {
			templ_7745c5c3_Var1 = templ.NopComponent
		}
		ctx = templ.ClearChildren(ctx)
		templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 1, "<script nonce=\"")
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		var templ_7745c5c3_Var2 string
		templ_7745c5c3_Var2, templ_7745c5c3_Err = templ.JoinStringErrs(templ.GetNonce(ctx))
		if templ_7745c5c3_Err != nil {
			return templ.Error{Err: templ_7745c5c3_Err, FileName: `internal/http/template/component/popover/floating_ui_core.templ`, Line: 6, Col: 36}
		}
		_, templ_7745c5c3_Err = templ_7745c5c3_Buffer.WriteString(templ.EscapeString(templ_7745c5c3_Var2))
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 2, "\">\n\t\t!(function (t, e) {\n\t\t\"object\" == typeof exports && \"undefined\" != typeof module\n\t\t\t? e(exports)\n\t\t\t: \"function\" == typeof define && define.amd\n\t\t\t? define([\"exports\"], e)\n\t\t\t: e(\n\t\t\t\t((t =\n\t\t\t\t\"undefined\" != typeof globalThis\n\t\t\t\t\t? globalThis\n\t\t\t\t\t: t || self).FloatingUICore = {})\n\t\t\t);\n\t\t})(this, function (t) {\n\t\t\"use strict\";\n\t\tconst e = [\"top\", \"right\", \"bottom\", \"left\"],\n\t\t\tn = [\"start\", \"end\"],\n\t\t\ti = e.reduce((t, e) => t.concat(e, e + \"-\" + n[0], e + \"-\" + n[1]), []),\n\t\t\to = Math.min,\n\t\t\tr = Math.max,\n\t\t\ta = { left: \"right\", right: \"left\", bottom: \"top\", top: \"bottom\" },\n\t\t\tl = { start: \"end\", end: \"start\" };\n\t\tfunction s(t, e, n) {\n\t\t\treturn r(t, o(e, n));\n\t\t}\n\t\tfunction f(t, e) {\n\t\t\treturn \"function\" == typeof t ? t(e) : t;\n\t\t}\n\t\tfunction c(t) {\n\t\t\treturn t.split(\"-\")[0];\n\t\t}\n\t\tfunction u(t) {\n\t\t\treturn t.split(\"-\")[1];\n\t\t}\n\t\tfunction m(t) {\n\t\t\treturn \"x\" === t ? \"y\" : \"x\";\n\t\t}\n\t\tfunction d(t) {\n\t\t\treturn \"y\" === t ? \"height\" : \"width\";\n\t\t}\n\t\tfunction g(t) {\n\t\t\treturn [\"top\", \"bottom\"].includes(c(t)) ? \"y\" : \"x\";\n\t\t}\n\t\tfunction p(t) {\n\t\t\treturn m(g(t));\n\t\t}\n\t\tfunction h(t, e, n) {\n\t\t\tvoid 0 === n && (n = !1);\n\t\t\tconst i = u(t),\n\t\t\to = p(t),\n\t\t\tr = d(o);\n\t\t\tlet a =\n\t\t\t\"x\" === o\n\t\t\t\t? i === (n ? \"end\" : \"start\")\n\t\t\t\t? \"right\"\n\t\t\t\t: \"left\"\n\t\t\t\t: \"start\" === i\n\t\t\t\t? \"bottom\"\n\t\t\t\t: \"top\";\n\t\t\treturn e.reference[r] > e.floating[r] && (a = w(a)), [a, w(a)];\n\t\t}\n\t\tfunction y(t) {\n\t\t\treturn t.replace(/start|end/g, (t) => l[t]);\n\t\t}\n\t\tfunction w(t) {\n\t\t\treturn t.replace(/left|right|bottom|top/g, (t) => a[t]);\n\t\t}\n\t\tfunction x(t) {\n\t\t\treturn \"number\" != typeof t\n\t\t\t? (function (t) {\n\t\t\t\treturn { top: 0, right: 0, bottom: 0, left: 0, ...t };\n\t\t\t\t})(t)\n\t\t\t: { top: t, right: t, bottom: t, left: t };\n\t\t}\n\t\tfunction v(t) {\n\t\t\tconst { x: e, y: n, width: i, height: o } = t;\n\t\t\treturn {\n\t\t\twidth: i,\n\t\t\theight: o,\n\t\t\ttop: n,\n\t\t\tleft: e,\n\t\t\tright: e + i,\n\t\t\tbottom: n + o,\n\t\t\tx: e,\n\t\t\ty: n,\n\t\t\t};\n\t\t}\n\t\tfunction b(t, e, n) {\n\t\t\tlet { reference: i, floating: o } = t;\n\t\t\tconst r = g(e),\n\t\t\ta = p(e),\n\t\t\tl = d(a),\n\t\t\ts = c(e),\n\t\t\tf = \"y\" === r,\n\t\t\tm = i.x + i.width / 2 - o.width / 2,\n\t\t\th = i.y + i.height / 2 - o.height / 2,\n\t\t\ty = i[l] / 2 - o[l] / 2;\n\t\t\tlet w;\n\t\t\tswitch (s) {\n\t\t\tcase \"top\":\n\t\t\t\tw = { x: m, y: i.y - o.height };\n\t\t\t\tbreak;\n\t\t\tcase \"bottom\":\n\t\t\t\tw = { x: m, y: i.y + i.height };\n\t\t\t\tbreak;\n\t\t\tcase \"right\":\n\t\t\t\tw = { x: i.x + i.width, y: h };\n\t\t\t\tbreak;\n\t\t\tcase \"left\":\n\t\t\t\tw = { x: i.x - o.width, y: h };\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tw = { x: i.x, y: i.y };\n\t\t\t}\n\t\t\tswitch (u(e)) {\n\t\t\tcase \"start\":\n\t\t\t\tw[a] -= y * (n && f ? -1 : 1);\n\t\t\t\tbreak;\n\t\t\tcase \"end\":\n\t\t\t\tw[a] += y * (n && f ? -1 : 1);\n\t\t\t}\n\t\t\treturn w;\n\t\t}\n\t\tasync function A(t, e) {\n\t\t\tvar n;\n\t\t\tvoid 0 === e && (e = {});\n\t\t\tconst { x: i, y: o, platform: r, rects: a, elements: l, strategy: s } = t,\n\t\t\t{\n\t\t\t\tboundary: c = \"clippingAncestors\",\n\t\t\t\trootBoundary: u = \"viewport\",\n\t\t\t\telementContext: m = \"floating\",\n\t\t\t\taltBoundary: d = !1,\n\t\t\t\tpadding: g = 0,\n\t\t\t} = f(e, t),\n\t\t\tp = x(g),\n\t\t\th = l[d ? (\"floating\" === m ? \"reference\" : \"floating\") : m],\n\t\t\ty = v(\n\t\t\t\tawait r.getClippingRect({\n\t\t\t\telement:\n\t\t\t\t\tnull ==\n\t\t\t\t\t(n = await (null == r.isElement ? void 0 : r.isElement(h))) || n\n\t\t\t\t\t? h\n\t\t\t\t\t: h.contextElement ||\n\t\t\t\t\t\t(await (null == r.getDocumentElement\n\t\t\t\t\t\t? void 0\n\t\t\t\t\t\t: r.getDocumentElement(l.floating))),\n\t\t\t\tboundary: c,\n\t\t\t\trootBoundary: u,\n\t\t\t\tstrategy: s,\n\t\t\t\t})\n\t\t\t),\n\t\t\tw =\n\t\t\t\t\"floating\" === m\n\t\t\t\t? { x: i, y: o, width: a.floating.width, height: a.floating.height }\n\t\t\t\t: a.reference,\n\t\t\tb = await (null == r.getOffsetParent\n\t\t\t\t? void 0\n\t\t\t\t: r.getOffsetParent(l.floating)),\n\t\t\tA = ((await (null == r.isElement ? void 0 : r.isElement(b))) &&\n\t\t\t\t(await (null == r.getScale ? void 0 : r.getScale(b)))) || {\n\t\t\t\tx: 1,\n\t\t\t\ty: 1,\n\t\t\t},\n\t\t\tR = v(\n\t\t\t\tr.convertOffsetParentRelativeRectToViewportRelativeRect\n\t\t\t\t? await r.convertOffsetParentRelativeRectToViewportRelativeRect({\n\t\t\t\t\telements: l,\n\t\t\t\t\trect: w,\n\t\t\t\t\toffsetParent: b,\n\t\t\t\t\tstrategy: s,\n\t\t\t\t\t})\n\t\t\t\t: w\n\t\t\t);\n\t\t\treturn {\n\t\t\ttop: (y.top - R.top + p.top) / A.y,\n\t\t\tbottom: (R.bottom - y.bottom + p.bottom) / A.y,\n\t\t\tleft: (y.left - R.left + p.left) / A.x,\n\t\t\tright: (R.right - y.right + p.right) / A.x,\n\t\t\t};\n\t\t}\n\t\tfunction R(t, e) {\n\t\t\treturn {\n\t\t\ttop: t.top - e.height,\n\t\t\tright: t.right - e.width,\n\t\t\tbottom: t.bottom - e.height,\n\t\t\tleft: t.left - e.width,\n\t\t\t};\n\t\t}\n\t\tfunction P(t) {\n\t\t\treturn e.some((e) => t[e] >= 0);\n\t\t}\n\t\tfunction D(t) {\n\t\t\tconst e = o(...t.map((t) => t.left)),\n\t\t\tn = o(...t.map((t) => t.top));\n\t\t\treturn {\n\t\t\tx: e,\n\t\t\ty: n,\n\t\t\twidth: r(...t.map((t) => t.right)) - e,\n\t\t\theight: r(...t.map((t) => t.bottom)) - n,\n\t\t\t};\n\t\t}\n\t\t(t.arrow = (t) => ({\n\t\t\tname: \"arrow\",\n\t\t\toptions: t,\n\t\t\tasync fn(e) {\n\t\t\tconst {\n\t\t\t\tx: n,\n\t\t\t\ty: i,\n\t\t\t\tplacement: r,\n\t\t\t\trects: a,\n\t\t\t\tplatform: l,\n\t\t\t\telements: c,\n\t\t\t\tmiddlewareData: m,\n\t\t\t\t} = e,\n\t\t\t\t{ element: g, padding: h = 0 } = f(t, e) || {};\n\t\t\tif (null == g) return {};\n\t\t\tconst y = x(h),\n\t\t\t\tw = { x: n, y: i },\n\t\t\t\tv = p(r),\n\t\t\t\tb = d(v),\n\t\t\t\tA = await l.getDimensions(g),\n\t\t\t\tR = \"y\" === v,\n\t\t\t\tP = R ? \"top\" : \"left\",\n\t\t\t\tD = R ? \"bottom\" : \"right\",\n\t\t\t\tT = R ? \"clientHeight\" : \"clientWidth\",\n\t\t\t\tO = a.reference[b] + a.reference[v] - w[v] - a.floating[b],\n\t\t\t\tE = w[v] - a.reference[v],\n\t\t\t\tL = await (null == l.getOffsetParent ? void 0 : l.getOffsetParent(g));\n\t\t\tlet k = L ? L[T] : 0;\n\t\t\t(k && (await (null == l.isElement ? void 0 : l.isElement(L)))) ||\n\t\t\t\t(k = c.floating[T] || a.floating[b]);\n\t\t\tconst C = O / 2 - E / 2,\n\t\t\t\tB = k / 2 - A[b] / 2 - 1,\n\t\t\t\tH = o(y[P], B),\n\t\t\t\tS = o(y[D], B),\n\t\t\t\tF = H,\n\t\t\t\tj = k - A[b] - S,\n\t\t\t\tz = k / 2 - A[b] / 2 + C,\n\t\t\t\tM = s(F, z, j),\n\t\t\t\tV =\n\t\t\t\t!m.arrow &&\n\t\t\t\tnull != u(r) &&\n\t\t\t\tz !== M &&\n\t\t\t\ta.reference[b] / 2 - (z < F ? H : S) - A[b] / 2 < 0,\n\t\t\t\tW = V ? (z < F ? z - F : z - j) : 0;\n\t\t\treturn {\n\t\t\t\t[v]: w[v] + W,\n\t\t\t\tdata: {\n\t\t\t\t[v]: M,\n\t\t\t\tcenterOffset: z - M - W,\n\t\t\t\t...(V && { alignmentOffset: W }),\n\t\t\t\t},\n\t\t\t\treset: V,\n\t\t\t};\n\t\t\t},\n\t\t})),\n\t\t\t(t.autoPlacement = function (t) {\n\t\t\treturn (\n\t\t\t\tvoid 0 === t && (t = {}),\n\t\t\t\t{\n\t\t\t\tname: \"autoPlacement\",\n\t\t\t\toptions: t,\n\t\t\t\tasync fn(e) {\n\t\t\t\t\tvar n, o, r;\n\t\t\t\t\tconst {\n\t\t\t\t\t\trects: a,\n\t\t\t\t\t\tmiddlewareData: l,\n\t\t\t\t\t\tplacement: s,\n\t\t\t\t\t\tplatform: m,\n\t\t\t\t\t\telements: d,\n\t\t\t\t\t} = e,\n\t\t\t\t\t{\n\t\t\t\t\t\tcrossAxis: g = !1,\n\t\t\t\t\t\talignment: p,\n\t\t\t\t\t\tallowedPlacements: w = i,\n\t\t\t\t\t\tautoAlignment: x = !0,\n\t\t\t\t\t\t...v\n\t\t\t\t\t} = f(t, e),\n\t\t\t\t\tb =\n\t\t\t\t\t\tvoid 0 !== p || w === i\n\t\t\t\t\t\t? (function (t, e, n) {\n\t\t\t\t\t\t\treturn (\n\t\t\t\t\t\t\t\tt\n\t\t\t\t\t\t\t\t? [\n\t\t\t\t\t\t\t\t\t...n.filter((e) => u(e) === t),\n\t\t\t\t\t\t\t\t\t...n.filter((e) => u(e) !== t),\n\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t: n.filter((t) => c(t) === t)\n\t\t\t\t\t\t\t).filter((n) => !t || u(n) === t || (!!e && y(n) !== n));\n\t\t\t\t\t\t\t})(p || null, x, w)\n\t\t\t\t\t\t: w,\n\t\t\t\t\tR = await A(e, v),\n\t\t\t\t\tP = (null == (n = l.autoPlacement) ? void 0 : n.index) || 0,\n\t\t\t\t\tD = b[P];\n\t\t\t\t\tif (null == D) return {};\n\t\t\t\t\tconst T = h(\n\t\t\t\t\tD,\n\t\t\t\t\ta,\n\t\t\t\t\tawait (null == m.isRTL ? void 0 : m.isRTL(d.floating))\n\t\t\t\t\t);\n\t\t\t\t\tif (s !== D) return { reset: { placement: b[0] } };\n\t\t\t\t\tconst O = [R[c(D)], R[T[0]], R[T[1]]],\n\t\t\t\t\tE = [\n\t\t\t\t\t\t...((null == (o = l.autoPlacement) ? void 0 : o.overflows) ||\n\t\t\t\t\t\t[]),\n\t\t\t\t\t\t{ placement: D, overflows: O },\n\t\t\t\t\t],\n\t\t\t\t\tL = b[P + 1];\n\t\t\t\t\tif (L)\n\t\t\t\t\treturn {\n\t\t\t\t\t\tdata: { index: P + 1, overflows: E },\n\t\t\t\t\t\treset: { placement: L },\n\t\t\t\t\t};\n\t\t\t\t\tconst k = E.map((t) => {\n\t\t\t\t\t\tconst e = u(t.placement);\n\t\t\t\t\t\treturn [\n\t\t\t\t\t\tt.placement,\n\t\t\t\t\t\te && g\n\t\t\t\t\t\t\t? t.overflows.slice(0, 2).reduce((t, e) => t + e, 0)\n\t\t\t\t\t\t\t: t.overflows[0],\n\t\t\t\t\t\tt.overflows,\n\t\t\t\t\t\t];\n\t\t\t\t\t}).sort((t, e) => t[1] - e[1]),\n\t\t\t\t\tC =\n\t\t\t\t\t\t(null ==\n\t\t\t\t\t\t(r = k.filter((t) =>\n\t\t\t\t\t\tt[2].slice(0, u(t[0]) ? 2 : 3).every((t) => t <= 0)\n\t\t\t\t\t\t)[0])\n\t\t\t\t\t\t? void 0\n\t\t\t\t\t\t: r[0]) || k[0][0];\n\t\t\t\t\treturn C !== s\n\t\t\t\t\t? {\n\t\t\t\t\t\tdata: { index: P + 1, overflows: E },\n\t\t\t\t\t\treset: { placement: C },\n\t\t\t\t\t\t}\n\t\t\t\t\t: {};\n\t\t\t\t},\n\t\t\t\t}\n\t\t\t);\n\t\t\t}),\n\t\t\t(t.computePosition = async (t, e, n) => {\n\t\t\tconst {\n\t\t\t\tplacement: i = \"bottom\",\n\t\t\t\tstrategy: o = \"absolute\",\n\t\t\t\tmiddleware: r = [],\n\t\t\t\tplatform: a,\n\t\t\t\t} = n,\n\t\t\t\tl = r.filter(Boolean),\n\t\t\t\ts = await (null == a.isRTL ? void 0 : a.isRTL(e));\n\t\t\tlet f = await a.getElementRects({\n\t\t\t\treference: t,\n\t\t\t\tfloating: e,\n\t\t\t\tstrategy: o,\n\t\t\t\t}),\n\t\t\t\t{ x: c, y: u } = b(f, i, s),\n\t\t\t\tm = i,\n\t\t\t\td = {},\n\t\t\t\tg = 0;\n\t\t\tfor (let n = 0; n < l.length; n++) {\n\t\t\t\tconst { name: r, fn: p } = l[n],\n\t\t\t\t{\n\t\t\t\t\tx: h,\n\t\t\t\t\ty: y,\n\t\t\t\t\tdata: w,\n\t\t\t\t\treset: x,\n\t\t\t\t} = await p({\n\t\t\t\t\tx: c,\n\t\t\t\t\ty: u,\n\t\t\t\t\tinitialPlacement: i,\n\t\t\t\t\tplacement: m,\n\t\t\t\t\tstrategy: o,\n\t\t\t\t\tmiddlewareData: d,\n\t\t\t\t\trects: f,\n\t\t\t\t\tplatform: a,\n\t\t\t\t\telements: { reference: t, floating: e },\n\t\t\t\t});\n\t\t\t\t(c = null != h ? h : c),\n\t\t\t\t(u = null != y ? y : u),\n\t\t\t\t(d = { ...d, [r]: { ...d[r], ...w } }),\n\t\t\t\tx &&\n\t\t\t\t\tg <= 50 &&\n\t\t\t\t\t(g++,\n\t\t\t\t\t\"object\" == typeof x &&\n\t\t\t\t\t(x.placement && (m = x.placement),\n\t\t\t\t\tx.rects &&\n\t\t\t\t\t\t(f =\n\t\t\t\t\t\t!0 === x.rects\n\t\t\t\t\t\t\t? await a.getElementRects({\n\t\t\t\t\t\t\t\treference: t,\n\t\t\t\t\t\t\t\tfloating: e,\n\t\t\t\t\t\t\t\tstrategy: o,\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t: x.rects),\n\t\t\t\t\t({ x: c, y: u } = b(f, m, s))),\n\t\t\t\t\t(n = -1));\n\t\t\t}\n\t\t\treturn { x: c, y: u, placement: m, strategy: o, middlewareData: d };\n\t\t\t}),\n\t\t\t(t.detectOverflow = A),\n\t\t\t(t.flip = function (t) {\n\t\t\treturn (\n\t\t\t\tvoid 0 === t && (t = {}),\n\t\t\t\t{\n\t\t\t\tname: \"flip\",\n\t\t\t\toptions: t,\n\t\t\t\tasync fn(e) {\n\t\t\t\t\tvar n, i;\n\t\t\t\t\tconst {\n\t\t\t\t\t\tplacement: o,\n\t\t\t\t\t\tmiddlewareData: r,\n\t\t\t\t\t\trects: a,\n\t\t\t\t\t\tinitialPlacement: l,\n\t\t\t\t\t\tplatform: s,\n\t\t\t\t\t\telements: m,\n\t\t\t\t\t} = e,\n\t\t\t\t\t{\n\t\t\t\t\t\tmainAxis: d = !0,\n\t\t\t\t\t\tcrossAxis: p = !0,\n\t\t\t\t\t\tfallbackPlacements: x,\n\t\t\t\t\t\tfallbackStrategy: v = \"bestFit\",\n\t\t\t\t\t\tfallbackAxisSideDirection: b = \"none\",\n\t\t\t\t\t\tflipAlignment: R = !0,\n\t\t\t\t\t\t...P\n\t\t\t\t\t} = f(t, e);\n\t\t\t\t\tif (null != (n = r.arrow) && n.alignmentOffset) return {};\n\t\t\t\t\tconst D = c(o),\n\t\t\t\t\tT = g(l),\n\t\t\t\t\tO = c(l) === l,\n\t\t\t\t\tE = await (null == s.isRTL ? void 0 : s.isRTL(m.floating)),\n\t\t\t\t\tL =\n\t\t\t\t\t\tx ||\n\t\t\t\t\t\t(O || !R\n\t\t\t\t\t\t? [w(l)]\n\t\t\t\t\t\t: (function (t) {\n\t\t\t\t\t\t\tconst e = w(t);\n\t\t\t\t\t\t\treturn [y(t), e, y(e)];\n\t\t\t\t\t\t\t})(l)),\n\t\t\t\t\tk = \"none\" !== b;\n\t\t\t\t\t!x &&\n\t\t\t\t\tk &&\n\t\t\t\t\tL.push(\n\t\t\t\t\t\t...(function (t, e, n, i) {\n\t\t\t\t\t\tconst o = u(t);\n\t\t\t\t\t\tlet r = (function (t, e, n) {\n\t\t\t\t\t\t\tconst i = [\"left\", \"right\"],\n\t\t\t\t\t\t\to = [\"right\", \"left\"],\n\t\t\t\t\t\t\tr = [\"top\", \"bottom\"],\n\t\t\t\t\t\t\ta = [\"bottom\", \"top\"];\n\t\t\t\t\t\t\tswitch (t) {\n\t\t\t\t\t\t\tcase \"top\":\n\t\t\t\t\t\t\tcase \"bottom\":\n\t\t\t\t\t\t\t\treturn n ? (e ? o : i) : e ? i : o;\n\t\t\t\t\t\t\tcase \"left\":\n\t\t\t\t\t\t\tcase \"right\":\n\t\t\t\t\t\t\t\treturn e ? r : a;\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\treturn [];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t})(c(t), \"start\" === n, i);\n\t\t\t\t\t\treturn (\n\t\t\t\t\t\t\to &&\n\t\t\t\t\t\t\t((r = r.map((t) => t + \"-\" + o)),\n\t\t\t\t\t\t\te && (r = r.concat(r.map(y)))),\n\t\t\t\t\t\t\tr\n\t\t\t\t\t\t);\n\t\t\t\t\t\t})(l, R, b, E)\n\t\t\t\t\t);\n\t\t\t\t\tconst C = [l, ...L],\n\t\t\t\t\tB = await A(e, P),\n\t\t\t\t\tH = [];\n\t\t\t\t\tlet S = (null == (i = r.flip) ? void 0 : i.overflows) || [];\n\t\t\t\t\tif ((d && H.push(B[D]), p)) {\n\t\t\t\t\tconst t = h(o, a, E);\n\t\t\t\t\tH.push(B[t[0]], B[t[1]]);\n\t\t\t\t\t}\n\t\t\t\t\tif (\n\t\t\t\t\t((S = [...S, { placement: o, overflows: H }]),\n\t\t\t\t\t!H.every((t) => t <= 0))\n\t\t\t\t\t) {\n\t\t\t\t\tvar F, j;\n\t\t\t\t\tconst t = ((null == (F = r.flip) ? void 0 : F.index) || 0) + 1,\n\t\t\t\t\t\te = C[t];\n\t\t\t\t\tif (e) {\n\t\t\t\t\t\tvar z;\n\t\t\t\t\t\tconst n = \"alignment\" === p && T !== g(e),\n\t\t\t\t\t\ti = (null == (z = S[0]) ? void 0 : z.overflows[0]) > 0;\n\t\t\t\t\t\tif (!n || i)\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tdata: { index: t, overflows: S },\n\t\t\t\t\t\t\treset: { placement: e },\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t\tlet n =\n\t\t\t\t\t\tnull ==\n\t\t\t\t\t\t(j = S.filter((t) => t.overflows[0] <= 0).sort(\n\t\t\t\t\t\t(t, e) => t.overflows[1] - e.overflows[1]\n\t\t\t\t\t\t)[0])\n\t\t\t\t\t\t? void 0\n\t\t\t\t\t\t: j.placement;\n\t\t\t\t\tif (!n)\n\t\t\t\t\t\tswitch (v) {\n\t\t\t\t\t\tcase \"bestFit\": {\n\t\t\t\t\t\t\tvar M;\n\t\t\t\t\t\t\tconst t =\n\t\t\t\t\t\t\tnull ==\n\t\t\t\t\t\t\t(M = S.filter((t) => {\n\t\t\t\t\t\t\t\tif (k) {\n\t\t\t\t\t\t\t\tconst e = g(t.placement);\n\t\t\t\t\t\t\t\treturn e === T || \"y\" === e;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\treturn !0;\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t.map((t) => [\n\t\t\t\t\t\t\t\tt.placement,\n\t\t\t\t\t\t\t\tt.overflows\n\t\t\t\t\t\t\t\t\t.filter((t) => t > 0)\n\t\t\t\t\t\t\t\t\t.reduce((t, e) => t + e, 0),\n\t\t\t\t\t\t\t\t])\n\t\t\t\t\t\t\t\t.sort((t, e) => t[1] - e[1])[0])\n\t\t\t\t\t\t\t\t? void 0\n\t\t\t\t\t\t\t\t: M[0];\n\t\t\t\t\t\t\tt && (n = t);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase \"initialPlacement\":\n\t\t\t\t\t\t\tn = l;\n\t\t\t\t\t\t}\n\t\t\t\t\tif (o !== n) return { reset: { placement: n } };\n\t\t\t\t\t}\n\t\t\t\t\treturn {};\n\t\t\t\t},\n\t\t\t\t}\n\t\t\t);\n\t\t\t}),\n\t\t\t(t.hide = function (t) {\n\t\t\treturn (\n\t\t\t\tvoid 0 === t && (t = {}),\n\t\t\t\t{\n\t\t\t\tname: \"hide\",\n\t\t\t\toptions: t,\n\t\t\t\tasync fn(e) {\n\t\t\t\t\tconst { rects: n } = e,\n\t\t\t\t\t{ strategy: i = \"referenceHidden\", ...o } = f(t, e);\n\t\t\t\t\tswitch (i) {\n\t\t\t\t\tcase \"referenceHidden\": {\n\t\t\t\t\t\tconst t = R(\n\t\t\t\t\t\tawait A(e, { ...o, elementContext: \"reference\" }),\n\t\t\t\t\t\tn.reference\n\t\t\t\t\t\t);\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\tdata: { referenceHiddenOffsets: t, referenceHidden: P(t) },\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t\tcase \"escaped\": {\n\t\t\t\t\t\tconst t = R(await A(e, { ...o, altBoundary: !0 }), n.floating);\n\t\t\t\t\t\treturn { data: { escapedOffsets: t, escaped: P(t) } };\n\t\t\t\t\t}\n\t\t\t\t\tdefault:\n\t\t\t\t\t\treturn {};\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t}\n\t\t\t);\n\t\t\t}),\n\t\t\t(t.inline = function (t) {\n\t\t\treturn (\n\t\t\t\tvoid 0 === t && (t = {}),\n\t\t\t\t{\n\t\t\t\tname: \"inline\",\n\t\t\t\toptions: t,\n\t\t\t\tasync fn(e) {\n\t\t\t\t\tconst {\n\t\t\t\t\t\tplacement: n,\n\t\t\t\t\t\telements: i,\n\t\t\t\t\t\trects: a,\n\t\t\t\t\t\tplatform: l,\n\t\t\t\t\t\tstrategy: s,\n\t\t\t\t\t} = e,\n\t\t\t\t\t{ padding: u = 2, x: m, y: d } = f(t, e),\n\t\t\t\t\tp = Array.from(\n\t\t\t\t\t\t(await (null == l.getClientRects\n\t\t\t\t\t\t? void 0\n\t\t\t\t\t\t: l.getClientRects(i.reference))) || []\n\t\t\t\t\t),\n\t\t\t\t\th = (function (t) {\n\t\t\t\t\t\tconst e = t.slice().sort((t, e) => t.y - e.y),\n\t\t\t\t\t\tn = [];\n\t\t\t\t\t\tlet i = null;\n\t\t\t\t\t\tfor (let t = 0; t < e.length; t++) {\n\t\t\t\t\t\tconst o = e[t];\n\t\t\t\t\t\t!i || o.y - i.y > i.height / 2\n\t\t\t\t\t\t\t? n.push([o])\n\t\t\t\t\t\t\t: n[n.length - 1].push(o),\n\t\t\t\t\t\t\t(i = o);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn n.map((t) => v(D(t)));\n\t\t\t\t\t})(p),\n\t\t\t\t\ty = v(D(p)),\n\t\t\t\t\tw = x(u);\n\t\t\t\t\tconst b = await l.getElementRects({\n\t\t\t\t\treference: {\n\t\t\t\t\t\tgetBoundingClientRect: function () {\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t2 === h.length &&\n\t\t\t\t\t\t\th[0].left > h[1].right &&\n\t\t\t\t\t\t\tnull != m &&\n\t\t\t\t\t\t\tnull != d\n\t\t\t\t\t\t)\n\t\t\t\t\t\t\treturn (\n\t\t\t\t\t\t\th.find(\n\t\t\t\t\t\t\t\t(t) =>\n\t\t\t\t\t\t\t\tm > t.left - w.left &&\n\t\t\t\t\t\t\t\tm < t.right + w.right &&\n\t\t\t\t\t\t\t\td > t.top - w.top &&\n\t\t\t\t\t\t\t\td < t.bottom + w.bottom\n\t\t\t\t\t\t\t) || y\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\tif (h.length >= 2) {\n\t\t\t\t\t\t\tif (\"y\" === g(n)) {\n\t\t\t\t\t\t\tconst t = h[0],\n\t\t\t\t\t\t\t\te = h[h.length - 1],\n\t\t\t\t\t\t\t\ti = \"top\" === c(n),\n\t\t\t\t\t\t\t\to = t.top,\n\t\t\t\t\t\t\t\tr = e.bottom,\n\t\t\t\t\t\t\t\ta = i ? t.left : e.left,\n\t\t\t\t\t\t\t\tl = i ? t.right : e.right;\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\ttop: o,\n\t\t\t\t\t\t\t\tbottom: r,\n\t\t\t\t\t\t\t\tleft: a,\n\t\t\t\t\t\t\t\tright: l,\n\t\t\t\t\t\t\t\twidth: l - a,\n\t\t\t\t\t\t\t\theight: r - o,\n\t\t\t\t\t\t\t\tx: a,\n\t\t\t\t\t\t\t\ty: o,\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tconst t = \"left\" === c(n),\n\t\t\t\t\t\t\te = r(...h.map((t) => t.right)),\n\t\t\t\t\t\t\ti = o(...h.map((t) => t.left)),\n\t\t\t\t\t\t\ta = h.filter((n) => (t ? n.left === i : n.right === e)),\n\t\t\t\t\t\t\tl = a[0].top,\n\t\t\t\t\t\t\ts = a[a.length - 1].bottom;\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\ttop: l,\n\t\t\t\t\t\t\tbottom: s,\n\t\t\t\t\t\t\tleft: i,\n\t\t\t\t\t\t\tright: e,\n\t\t\t\t\t\t\twidth: e - i,\n\t\t\t\t\t\t\theight: s - l,\n\t\t\t\t\t\t\tx: i,\n\t\t\t\t\t\t\ty: l,\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn y;\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tfloating: i.floating,\n\t\t\t\t\tstrategy: s,\n\t\t\t\t\t});\n\t\t\t\t\treturn a.reference.x !== b.reference.x ||\n\t\t\t\t\ta.reference.y !== b.reference.y ||\n\t\t\t\t\ta.reference.width !== b.reference.width ||\n\t\t\t\t\ta.reference.height !== b.reference.height\n\t\t\t\t\t? { reset: { rects: b } }\n\t\t\t\t\t: {};\n\t\t\t\t},\n\t\t\t\t}\n\t\t\t);\n\t\t\t}),\n\t\t\t(t.limitShift = function (t) {\n\t\t\treturn (\n\t\t\t\tvoid 0 === t && (t = {}),\n\t\t\t\t{\n\t\t\t\toptions: t,\n\t\t\t\tfn(e) {\n\t\t\t\t\tconst { x: n, y: i, placement: o, rects: r, middlewareData: a } = e,\n\t\t\t\t\t{ offset: l = 0, mainAxis: s = !0, crossAxis: u = !0 } = f(t, e),\n\t\t\t\t\td = { x: n, y: i },\n\t\t\t\t\tp = g(o),\n\t\t\t\t\th = m(p);\n\t\t\t\t\tlet y = d[h],\n\t\t\t\t\tw = d[p];\n\t\t\t\t\tconst x = f(l, e),\n\t\t\t\t\tv =\n\t\t\t\t\t\t\"number\" == typeof x\n\t\t\t\t\t\t? { mainAxis: x, crossAxis: 0 }\n\t\t\t\t\t\t: { mainAxis: 0, crossAxis: 0, ...x };\n\t\t\t\t\tif (s) {\n\t\t\t\t\tconst t = \"y\" === h ? \"height\" : \"width\",\n\t\t\t\t\t\te = r.reference[h] - r.floating[t] + v.mainAxis,\n\t\t\t\t\t\tn = r.reference[h] + r.reference[t] - v.mainAxis;\n\t\t\t\t\ty < e ? (y = e) : y > n && (y = n);\n\t\t\t\t\t}\n\t\t\t\t\tif (u) {\n\t\t\t\t\tvar b, A;\n\t\t\t\t\tconst t = \"y\" === h ? \"width\" : \"height\",\n\t\t\t\t\t\te = [\"top\", \"left\"].includes(c(o)),\n\t\t\t\t\t\tn =\n\t\t\t\t\t\tr.reference[p] -\n\t\t\t\t\t\tr.floating[t] +\n\t\t\t\t\t\t((e && (null == (b = a.offset) ? void 0 : b[p])) || 0) +\n\t\t\t\t\t\t(e ? 0 : v.crossAxis),\n\t\t\t\t\t\ti =\n\t\t\t\t\t\tr.reference[p] +\n\t\t\t\t\t\tr.reference[t] +\n\t\t\t\t\t\t(e ? 0 : (null == (A = a.offset) ? void 0 : A[p]) || 0) -\n\t\t\t\t\t\t(e ? v.crossAxis : 0);\n\t\t\t\t\tw < n ? (w = n) : w > i && (w = i);\n\t\t\t\t\t}\n\t\t\t\t\treturn { [h]: y, [p]: w };\n\t\t\t\t},\n\t\t\t\t}\n\t\t\t);\n\t\t\t}),\n\t\t\t(t.offset = function (t) {\n\t\t\treturn (\n\t\t\t\tvoid 0 === t && (t = 0),\n\t\t\t\t{\n\t\t\t\tname: \"offset\",\n\t\t\t\toptions: t,\n\t\t\t\tasync fn(e) {\n\t\t\t\t\tvar n, i;\n\t\t\t\t\tconst { x: o, y: r, placement: a, middlewareData: l } = e,\n\t\t\t\t\ts = await (async function (t, e) {\n\t\t\t\t\t\tconst { placement: n, platform: i, elements: o } = t,\n\t\t\t\t\t\tr = await (null == i.isRTL ? void 0 : i.isRTL(o.floating)),\n\t\t\t\t\t\ta = c(n),\n\t\t\t\t\t\tl = u(n),\n\t\t\t\t\t\ts = \"y\" === g(n),\n\t\t\t\t\t\tm = [\"left\", \"top\"].includes(a) ? -1 : 1,\n\t\t\t\t\t\td = r && s ? -1 : 1,\n\t\t\t\t\t\tp = f(e, t);\n\t\t\t\t\t\tlet {\n\t\t\t\t\t\tmainAxis: h,\n\t\t\t\t\t\tcrossAxis: y,\n\t\t\t\t\t\talignmentAxis: w,\n\t\t\t\t\t\t} = \"number\" == typeof p\n\t\t\t\t\t\t? { mainAxis: p, crossAxis: 0, alignmentAxis: null }\n\t\t\t\t\t\t: {\n\t\t\t\t\t\t\tmainAxis: p.mainAxis || 0,\n\t\t\t\t\t\t\tcrossAxis: p.crossAxis || 0,\n\t\t\t\t\t\t\talignmentAxis: p.alignmentAxis,\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\treturn (\n\t\t\t\t\t\tl && \"number\" == typeof w && (y = \"end\" === l ? -1 * w : w),\n\t\t\t\t\t\ts ? { x: y * d, y: h * m } : { x: h * m, y: y * d }\n\t\t\t\t\t\t);\n\t\t\t\t\t})(e, t);\n\t\t\t\t\treturn a === (null == (n = l.offset) ? void 0 : n.placement) &&\n\t\t\t\t\tnull != (i = l.arrow) &&\n\t\t\t\t\ti.alignmentOffset\n\t\t\t\t\t? {}\n\t\t\t\t\t: { x: o + s.x, y: r + s.y, data: { ...s, placement: a } };\n\t\t\t\t},\n\t\t\t\t}\n\t\t\t);\n\t\t\t}),\n\t\t\t(t.rectToClientRect = v),\n\t\t\t(t.shift = function (t) {\n\t\t\treturn (\n\t\t\t\tvoid 0 === t && (t = {}),\n\t\t\t\t{\n\t\t\t\tname: \"shift\",\n\t\t\t\toptions: t,\n\t\t\t\tasync fn(e) {\n\t\t\t\t\tconst { x: n, y: i, placement: o } = e,\n\t\t\t\t\t{\n\t\t\t\t\t\tmainAxis: r = !0,\n\t\t\t\t\t\tcrossAxis: a = !1,\n\t\t\t\t\t\tlimiter: l = {\n\t\t\t\t\t\tfn: (t) => {\n\t\t\t\t\t\t\tlet { x: e, y: n } = t;\n\t\t\t\t\t\t\treturn { x: e, y: n };\n\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t...u\n\t\t\t\t\t} = f(t, e),\n\t\t\t\t\td = { x: n, y: i },\n\t\t\t\t\tp = await A(e, u),\n\t\t\t\t\th = g(c(o)),\n\t\t\t\t\ty = m(h);\n\t\t\t\t\tlet w = d[y],\n\t\t\t\t\tx = d[h];\n\t\t\t\t\tif (r) {\n\t\t\t\t\tconst t = \"y\" === y ? \"bottom\" : \"right\";\n\t\t\t\t\tw = s(w + p[\"y\" === y ? \"top\" : \"left\"], w, w - p[t]);\n\t\t\t\t\t}\n\t\t\t\t\tif (a) {\n\t\t\t\t\tconst t = \"y\" === h ? \"bottom\" : \"right\";\n\t\t\t\t\tx = s(x + p[\"y\" === h ? \"top\" : \"left\"], x, x - p[t]);\n\t\t\t\t\t}\n\t\t\t\t\tconst v = l.fn({ ...e, [y]: w, [h]: x });\n\t\t\t\t\treturn {\n\t\t\t\t\t...v,\n\t\t\t\t\tdata: { x: v.x - n, y: v.y - i, enabled: { [y]: r, [h]: a } },\n\t\t\t\t\t};\n\t\t\t\t},\n\t\t\t\t}\n\t\t\t);\n\t\t\t}),\n\t\t\t(t.size = function (t) {\n\t\t\treturn (\n\t\t\t\tvoid 0 === t && (t = {}),\n\t\t\t\t{\n\t\t\t\tname: \"size\",\n\t\t\t\toptions: t,\n\t\t\t\tasync fn(e) {\n\t\t\t\t\tvar n, i;\n\t\t\t\t\tconst { placement: a, rects: l, platform: s, elements: m } = e,\n\t\t\t\t\t{ apply: d = () => {}, ...p } = f(t, e),\n\t\t\t\t\th = await A(e, p),\n\t\t\t\t\ty = c(a),\n\t\t\t\t\tw = u(a),\n\t\t\t\t\tx = \"y\" === g(a),\n\t\t\t\t\t{ width: v, height: b } = l.floating;\n\t\t\t\t\tlet R, P;\n\t\t\t\t\t\"top\" === y || \"bottom\" === y\n\t\t\t\t\t? ((R = y),\n\t\t\t\t\t\t(P =\n\t\t\t\t\t\tw ===\n\t\t\t\t\t\t((await (null == s.isRTL ? void 0 : s.isRTL(m.floating)))\n\t\t\t\t\t\t\t? \"start\"\n\t\t\t\t\t\t\t: \"end\")\n\t\t\t\t\t\t\t? \"left\"\n\t\t\t\t\t\t\t: \"right\"))\n\t\t\t\t\t: ((P = y), (R = \"end\" === w ? \"top\" : \"bottom\"));\n\t\t\t\t\tconst D = b - h.top - h.bottom,\n\t\t\t\t\tT = v - h.left - h.right,\n\t\t\t\t\tO = o(b - h[R], D),\n\t\t\t\t\tE = o(v - h[P], T),\n\t\t\t\t\tL = !e.middlewareData.shift;\n\t\t\t\t\tlet k = O,\n\t\t\t\t\tC = E;\n\t\t\t\t\tif (\n\t\t\t\t\t(null != (n = e.middlewareData.shift) && n.enabled.x && (C = T),\n\t\t\t\t\tnull != (i = e.middlewareData.shift) && i.enabled.y && (k = D),\n\t\t\t\t\tL && !w)\n\t\t\t\t\t) {\n\t\t\t\t\tconst t = r(h.left, 0),\n\t\t\t\t\t\te = r(h.right, 0),\n\t\t\t\t\t\tn = r(h.top, 0),\n\t\t\t\t\t\ti = r(h.bottom, 0);\n\t\t\t\t\tx\n\t\t\t\t\t\t? (C =\n\t\t\t\t\t\t\tv - 2 * (0 !== t || 0 !== e ? t + e : r(h.left, h.right)))\n\t\t\t\t\t\t: (k =\n\t\t\t\t\t\t\tb - 2 * (0 !== n || 0 !== i ? n + i : r(h.top, h.bottom)));\n\t\t\t\t\t}\n\t\t\t\t\tawait d({ ...e, availableWidth: C, availableHeight: k });\n\t\t\t\t\tconst B = await s.getDimensions(m.floating);\n\t\t\t\t\treturn v !== B.width || b !== B.height\n\t\t\t\t\t? { reset: { rects: !0 } }\n\t\t\t\t\t: {};\n\t\t\t\t},\n\t\t\t\t}\n\t\t\t);\n\t\t\t});\n\t\t});\n\t</script>")
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		return nil
	})
}

var _ = templruntime.GeneratedTemplate
